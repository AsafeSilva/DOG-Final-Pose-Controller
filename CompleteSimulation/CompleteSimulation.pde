import processing.video.*;
import processing.serial.*;
import pt.citar.diablu.processing.nxt.*;

LegoNXT lego;

Capture cam;

PImage map;

PRM prm;
Node start, goal;

Robot robot;
Pose currentPose;
Pose target;

float vmax = 0.1;
float wmax = 3.63;

List<Node> path;
int currentNode = 1;
int WAYPOINT_DISTANCE = 30;

boolean run = false;

void settings() {
  size(CAMERA_WIDTH, CAMERA_HEIGHT);
}

void setup() {

  println("Inicializando bluetooth");
  lego = new LegoNXT(this, BT_LEGO);

  println("Inicializando camera");
  cam = new Capture(this, CAMERA_WIDTH, CAMERA_HEIGHT, EXTERNAL_CAM);
  cam.start();

  println("Inicializando mapa");
  map = loadImage(MAP_NAME);

  println("Inicializando vari√°veis");
  robot = new Robot();
  currentPose = new Pose();
  target = new Pose();

  // ==== Probabilistic Roadmap
  prm = new PRM(map);

  // ==== PRM Parameters
  prm.MAX_NODES = 70;
  prm.MIN_DIST_NEIGHBORS = 30;
  prm.MAX_DIST_NEIGHBORS = 100;
  prm.SAFE_ZONE = 0;
  prm.OPTIMIZE = true;

  prm.plan();

  start = new Node(color(0, 255, 0), -1);
  goal = new Node(color(255, 0, 0), -2);

  path = new ArrayList<Node>();
}

void draw() {
  noTint();
  image(cam, 0, 0);
  tint(255, 50);
  image(map, 0, 0);

  // ===== Draws PRM variables
  prm.drawEdges();
  prm.drawNodes();
  prm.drawPath();

  // ===== Reads the robot pose through the camera
  capturePose(currentPose);
  robot.setPose(currentPose);

  // ===== Sets PRM start node as the robot pose
  start.setX((int)currentPose.getX());
  start.setY((int) (height - currentPose.getY()));

  // ===== Performs iteration of the path generated by the PRM
  if (!path.isEmpty()) {
    if (dist(currentPose.getX(), currentPose.getY(), path.get(currentNode).getX(), height-path.get(currentNode).getY()) < WAYPOINT_DISTANCE) {
      if (path.get(currentNode).getID() != goal.getID()) {
        currentNode++;
      } else {
        currentNode = path.size() - 1;
      }
    }

    target.setX(path.get(currentNode).getX());
    target.setY(height - path.get(currentNode).getY());

    noFill();
    stroke(255, 255, 255);
    ellipse(path.get(currentNode).getX(), path.get(currentNode).getY(), WAYPOINT_DISTANCE, WAYPOINT_DISTANCE);
  }


  // ===== Final pose controller
  float[] error = robot.getError(target);
  float rho = error[0];
  float alpha = error[1];

  if (rho >= 15.0) {
    float Kw = (abs(wmax) - 0.5 * vmax) / PI;
    Kw = abs(Kw);

    float v = (float) (vmax * Math.tanh(rho) * cos(alpha));
    float w = (float) (Kw * alpha + vmax * Math.tanh(rho) * sin(alpha) * cos(alpha) / rho);

    if (run)  robot.move(v, w);
    else      robot.stop();
  } else {
    robot.stop();
  }


  // ===== Paint
  fill(255);
  stroke(50);
  ellipse(currentPose.getX(), height-currentPose.getY(), 10, 10);

  textSize(10);
  text("Power: (" + robot.powerD + ", " + robot.powerE + ")", 10, 20);
  text("Pose: (" + (int)currentPose.getX() + ", " + (int)currentPose.getY() + ", " + (int)degrees(currentPose.getDirection()) + ")", 10, 35);
  text("Error: (" + (int)rho + ", " + (int)degrees(alpha) + ")", 10, 50);
}


void mousePressed() {
  if (mouseButton == RIGHT) {
    getRobotColors();
  } else if (mouseButton == LEFT) {
    goal.setPosition(mouseX, mouseY);
    
    prm.path(start, goal);
    path = prm.getPath();
    Collections.reverse(path);

    currentNode = 1;
  }
}

void keyPressed() {
  run = !run;
}
