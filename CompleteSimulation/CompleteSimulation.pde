import processing.video.*;
import processing.serial.*;
import pt.citar.diablu.processing.nxt.*;

LegoNXT lego;

Capture cam;

float[] error;
float rho, alpha, theta;
float phi, betha;
boolean isOnTarget = false;

PImage map;

float IS_ON_TARGET = 30.0;

PRM prm;
Node start, goal;

Robot robot;
Pose currentPose;
Pose target;
Pose targetTemp;

float vmax = 0.1;
float wmax = 3.63;
float SAFE_DISTANCE = 50;

List<Node> path;
int currentNode = 1;
int WAYPOINT_DISTANCE = 60;

boolean run = false;

void settings() {
  size(CAMERA_WIDTH, CAMERA_HEIGHT);
}

void setup() {

  println("Inicializando bluetooth");
  lego = new LegoNXT(this, BT_LEGO);

  println("Inicializando camera");
  cam = new Capture(this, CAMERA_WIDTH, CAMERA_HEIGHT, EXTERNAL_CAM);
  cam.start();

  println("Inicializando mapa");
  map = loadImage(MAP_NAME);

  println("Inicializando variáveis");
  robot = new Robot(map);
  currentPose = new Pose();
  target = new Pose();
  targetTemp = new Pose();

  // ==== Probabilistic Roadmap
  prm = new PRM(map);

  // ==== PRM Parameters
  prm.MAX_NODES = 70;
  prm.MIN_DIST_NEIGHBORS = 30;
  prm.MAX_DIST_NEIGHBORS = 100;
  prm.SAFE_ZONE = 10;
  prm.OPTIMIZE = true;

  prm.plan();

  start = new Node(color(0, 255, 0), -1);
  goal = new Node(color(255, 0, 0), -2);

  path = new ArrayList<Node>();
}

void draw() {
  noTint();
  image(cam, 0, 0);
  tint(255, 50);
  image(map, 0, 0);

  // ===== Draws PRM variables
  //prm.drawEdges();
  //prm.drawNodes();
  prm.drawPath();

  // ===== Reads the robot pose through the camera
  capturePose(currentPose);
  robot.setPose(currentPose);

  // ===== Sets PRM start node as the robot pose
  start.setX((int)currentPose.getX());
  start.setY((int)currentPose.getY());

  // ===== Performs iteration of the path generated by the PRM
  if (!path.isEmpty()) {
    if (dist(currentPose.getX(), currentPose.getY(), path.get(currentNode).getX(), path.get(currentNode).getY()) < WAYPOINT_DISTANCE) {
      if (path.get(currentNode).getID() != goal.getID()) {
        currentNode++;
      } else {
        currentNode = path.size() - 1;
      }
    }

    target.setX(path.get(currentNode).getX());
    target.setY(path.get(currentNode).getY());

    noFill();
    stroke(255, 255, 255);
    ellipse(path.get(currentNode).getX(), path.get(currentNode).getY(), 2*WAYPOINT_DISTANCE, 2*WAYPOINT_DISTANCE);
    ellipse(goal.getX(), goal.getY(), 2*IS_ON_TARGET, 2*IS_ON_TARGET);
  }

  // ===== Final pose controller
  error = robot.getError(target);
  rho = error[0];
  alpha = error[1];
  theta = error[2];
  
  isOnTarget = rho < IS_ON_TARGET ? true : false;
  
  float shortestSensor = SAFE_DISTANCE;
  int shortestSensorID = -1;
  float shortestDistance;

  // Realiza a leitura dos 16 sensores
  for (int i = 0; i < 16; i++)  robot.getSonar(i).read(currentPose, robot.occGrid);

  // Procura o sensor frontal que leu a menor distância
  for (int i = 0; i < 8; i++) {
    float distance = robot.getSonar(i).getDistance();
    //if ( (distance > 30) && (distance < 70) ) {
    if (distance < shortestSensor) {
      shortestSensor = distance;
      shortestSensorID = i;
    }
    //}
  }

  // Realiza uma média entre o sensor com menor distância e seus vizinhos
  if (shortestSensor < SAFE_DISTANCE) {
    int centralSensorID = shortestSensorID;
    int rightSensorID = centralSensorID + 1;
    int leftSensorID = centralSensorID == 0 ? 15 : centralSensorID - 1;

    float centralDistance = robot.getSonar(centralSensorID).getDistance();
    float rightDistance = robot.getSonar(rightSensorID).getDistance();
    float leftDistance = robot.getSonar(leftSensorID).getDistance();

    float centralAngle = robot.getSonar(centralSensorID).getDirection();
    float rightAngle = robot.getSonar(rightSensorID).getDirection();
    float leftAngle = robot.getSonar(leftSensorID).getDirection();

    float difRightCentral = abs(centralDistance - rightDistance);
    float difLeftCentral = abs(centralDistance - leftDistance);
    float difRightLeft = abs(leftDistance - rightDistance);

    if (difLeftCentral < difRightCentral) {
      shortestDistance = difLeftCentral;
      betha = (leftAngle + centralAngle)/2;
    } else {
      shortestDistance = difRightCentral;
      betha = (rightAngle + centralAngle)/2;
    }

    if (difRightLeft < shortestDistance) {
      shortestDistance = difRightLeft;
      betha = (rightAngle + leftAngle)/2;
    }

    // Calcula o ângulo de rotação para o alvo virtual
    int reverseSign = betha > 0 ? -1 : 1;
    phi = ((HALF_PI - abs(betha)) * reverseSign) - alpha;
  } else {
    phi = 0;
    betha = 0;
  }

  // Calcula um ponto próximo ao robô na direção do alvo
  float xNear = currentPose.getX() + 100 * cos(theta);
  float yNear = currentPose.getY() + 100 * sin(theta);

  // Calcula o alvo virtual através do ângulo de rotação 'phi'
  float xTemp = (xNear - currentPose.getX()) * cos(phi) - (yNear - currentPose.getY()) * sin(phi);
  float yTemp = (xNear - currentPose.getX()) * sin(phi) + (yNear - currentPose.getY()) * cos(phi);
  
  targetTemp.setX(xTemp + currentPose.getX());
  targetTemp.setY(yTemp + currentPose.getY());

  // Calcula novo erro em relação ao alvo virtual
  error = robot.getError(targetTemp);
  rho = error[0];
  alpha = error[1];


  if (!isOnTarget){
    float Kw = (abs(wmax) - 0.5 * vmax) / PI;
    Kw = abs(Kw);

    float v = (float) (vmax * Math.tanh(rho) * cos(alpha));
    float w = (float) (Kw * alpha + vmax * Math.tanh(rho) * sin(alpha) * cos(alpha) / rho);

    if (run)  robot.move(v, w);
    else      robot.stop();
  } else {
    robot.stop();
  }


  // ===== Paint
  fill(255);
  stroke(50);
  ellipse(currentPose.getX(), currentPose.getY(), 10, 10);

  textSize(10);
  text("Power: (" + robot.powerD + ", " + robot.powerE + ")", 10, 20);
  text("Pose: (" + (int)currentPose.getX() + ", " + (int)currentPose.getY() + ", " + (int)degrees(currentPose.getDirection()) + ")", 10, 35);
  text("Error: (" + (int)rho + ", " + (int)degrees(alpha) + ")", 10, 50);

  for (int i = 0; i < 16; i++) {
    Sonar sonar = robot.getSonar(i);
    stroke(0,0,255);
    if(sonar.getDistance() < SAFE_DISTANCE){
      stroke(255,0,0);
    }
    line(sonar.getStartPointX(), sonar.getStartPointY(), sonar.getObstacleX(), sonar.getObstacleY());
  }
  
  stroke(255, 100, 0);
  line(currentPose.getX(), currentPose.getY(), targetTemp.getX(), targetTemp.getY());
}


void mousePressed() {
  if (mouseButton == RIGHT) {
    getRobotColors();
  } else if (mouseButton == LEFT) {
    goal.setPosition(mouseX, mouseY);

    prm.path(start, goal);
    path = prm.getPath();
    Collections.reverse(path);

    currentNode = 1;
  }
}

void keyPressed() {
  run = !run;
}
